// Centralized string templates. Keep them simple and parametric where needed.

pub fn main_py() -> &'static str {
    r#"
from src.app_logging.glogger import setup_logging
import logging

def main():
    setup_logging()
    log = logging.getLogger("src.app")
    log.info("Hello from isolated logging")

if __name__ == "__main__":
    main()



"#
}

pub fn vscode_launch_json() -> &'static str {
    r#"{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Python: Current file",
      "type": "debugpy",
      "request": "launch",
      "program": "${file}",
      "cwd": "${workspaceFolder}",
      "env": {
        "PYTHONPATH": "${workspaceFolder}:${workspaceFolder}/src:${workspaceFolder}/Notebooks"
      },
      "console": "integratedTerminal",
      "justMyCode": true,
      "subProcess": true
    },
    {
      "name": "Python: Module src.main",
      "type": "debugpy",
      "request": "launch",
      "module": "src.main",
      "cwd": "${workspaceFolder}",
      "env": {
        "PYTHONPATH": "${workspaceFolder}:${workspaceFolder}/src:${workspaceFolder}/Notebooks"
      },
      "console": "integratedTerminal",
      "justMyCode": true,
      "subProcess": true
    }
  ]
}"#
}

pub fn vscode_settings_json() -> &'static str {
    r#"{
  "python.defaultInterpreterPath": "${workspaceFolder}/.venv/bin/python",
  "python.terminal.activateEnvironment": true,
  "python.analysis.extraPaths": [
    "${workspaceFolder}",
    "${workspaceFolder}/src",
    "${workspaceFolder}/Notebooks"
  ],
  "python.envFile": "${workspaceFolder}/.env",
  "jupyter.envFile": "${workspaceFolder}/.env",
  "[python]": {
    "editor.defaultFormatter": "ms-python.black-formatter",
    "editor.formatOnSave": true
  },
  "black-formatter.importStrategy": "fromEnvironment",
  "black-formatter.path": ["${workspaceFolder}/.venv/bin/black"],
  "black-formatter.args": ["--line-length", "100"],
  "notebook.defaultFormatter": "ms-python.black-formatter"
}"#
}

pub fn vscode_tasks_json() -> &'static str {
    r#"{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Run (uv): src.main",
      "type": "shell",
      "command": "uv run python -m src.main",
      "options": { "cwd": "${workspaceFolder}", "env": { "PYTHONPATH": "${workspaceFolder}" } },
      "problemMatcher": []
    }
  ]
}"#
}

pub fn dotenv() -> &'static str {
    "PYTHONPATH=.:./src:./Notebooks\nENV=dev\n"
}

pub fn envrc() -> &'static str {
    r#"export PYTHONPATH="${PYTHONPATH}:$PWD:$PWD/src:$PWD/Notebooks"
if [ -f ./.env ]; then
  set -a
  . ./.env
  set +a
fi
"#
}

pub fn pyrefly_toml(project: &str, py_full: &str) -> String {
    format!(
        r#"[project]
name = "{project}"
python = "{py_full}"

[paths]
src = "src"
notebooks = "Notebooks"
venv = ".venv"
env = ".env"

[imports]
import_roots = ["src"]

[lint]
enable = ["ruff"]
format = ["black"]

[test]
runner = "pytest"
coverage = true
"#
    )
}

pub fn pyrightconfig_json(mm: &str) -> String {
    format!(
        r#"{{
  "pythonVersion": "{mm}",
  "pythonPlatform": "Darwin",
  "typeCheckingMode": "basic",
  "reportMissingImports": "warning",
  "useLibraryCodeForTypes": true,
  "include": [".", "src/"],
  "exclude": ["**/__pycache__", ".venv"],
  "venvPath": ".",
  "venv": ".venv",
  "executionEnvironments": [
    {{
      "root": ".",
      "extraPaths": [
        "./src",
        "./Notebooks/",
        ".venv/lib/python{mm}/site-packages"
      ]
    }}
  ]
}}"#
    )
}

pub fn pyproject_toml(project: &str, mm: &str, mm_nodec: &str) -> String {
    format!(
        r#"[project]
name = "{project}"
version = "0.1.0"
description = "Minimal project template"
readme = "README.md"
requires-python = ">={mm}"
authors = [{{ name = "Your Name" }}]
dependencies = []

[tool.uv]

[project.optional-dependencies]
dev = [
  "ruff>=0.6.0",
  "black>=24.0.0",
  "pyright>=1.1.380",
  "pytest>=8.0.0",
  "pytest-cov>=5.0.0",
  "ipykernel>=6.0.0",
  "rich>=13.0.0"
]

[tool.ruff]
line-length = 100
target-version = "py{mm_nodec}"
extend-exclude = [".venv"]
fix = true
"#
    )
}

pub fn gitignore() -> &'static str {
    r#".venv/
__pycache__/
*.pyc
.env
.ipynb_checkpoints/
.coverage
.htmlcov/
.mypy_cache/
.pytest_cache/
dist/
build/
"#
}

pub fn readme_md(project: &str) -> String {
    format!(
        r#"# {project}

Generated by PY-PROJ scaffolder.

## Setup

```bash
cd {project}
direnv allow     # or: source .venv/bin/activate
uv pip install -e ".[dev]"
Running
uv run python -m src.main

# Format code
uvx black .

# Lint code
uvx ruff check --fix

# Run tests
uv run pytest

# Type checking
uvx pyright
```
Structure
src/ - Main source code
tests/ - Test files
Notebooks/ - Jupyter notebooks
.vscode/ - VS Code configuration
pyproject.toml - Project configuration
pyrefly.toml - Custom project metadata
"#
    )
}

// ------------------ app_logging templates ------------------
pub fn app_logging_my_colored_formatter_py() -> &'static str {
    r#"

import logging
import datetime as dt
from src.app_logging.constants import *


class MyColoredFormatter(logging.Formatter):
    """
    Custom log formatter to add colors to log messages based on the log level
    and other attributes such as timestamp, filename, function name, and line number.
    """

    def format(self, record):
        # Generate timestamp with formatTime method including timezone
        asctime = f"{TIME_COLOR}{self.formatTime(record, self.datefmt)}{RESET}"

        # Add color to different fields
        log_color = COLORS.get(record.levelname, RESET)
        filename = f"{FILENAME_COLOR}{record.filename}{RESET}"
        funcName = f"{FUNCNAME_COLOR}{record.funcName}{RESET}"
        lineno = f"{LINENO_COLOR}{record.lineno}{RESET}"
        levelname = f"{log_color}{record.levelname}{RESET}"
        message = f"{log_color}{record.getMessage()}{RESET}"

        # Construct formatted log line
        log_line = f"{asctime}: {filename}: {funcName}: L{lineno}: {levelname}: {message}"
        return log_line
"#
}

pub fn app_logging_config07_json() -> &'static str {
    r#"
{
  "version": 1,
  "disable_existing_loggers": false,

  "formatters": {
    "simple": {
      "format": "%(asctime)s: %(filename)s: %(funcName)s: %(lineno)d: %(levelname)s: %(message)s",
      "datefmt": "DATE: %Y-%m-%d TIME:%H:%M:%S [%z]"
    },
    "colored": {
      "()": "src.app_logging.MyColoredFormatter.MyColoredFormatter",
      "format": "%(asctime)s: %(filename)s: %(funcName)s: L%(lineno)d: %(levelname)s: %(message)s",
      "datefmt": "DATE: %Y-%m-%d TIME:%H:%M:%S [%z]"
    },
    "json": {
      "()": "src.app_logging.myCustomJsonClass01.MyJSONFormatter",
      "fmt_keys": {
        "level": "levelname",
        "message": "message",
        "timestamp": "timestamp",
        "logger": "name",
        "module": "module",
        "function": "funcName",
        "line": "lineno",
        "thread_name": "threadName"
      }
    }
  },

  "filters": {
    "stdout_filter": { "()": "src.app_logging.myFilters.StdoutFilter" },
    "stderr_filter": { "()": "src.app_logging.myFilters.StderrFilter" },
    "only_src":      { "()": "logging.Filter", "name": "src" }
  },

  "handlers": {
    "stdout": {
      "class": "logging.StreamHandler",
      "formatter": "colored",
      "stream": "ext://sys.stdout",
      "filters": ["stdout_filter", "only_src"]
    },
    "stderr": {
      "class": "logging.StreamHandler",
      "level": "WARNING",
      "formatter": "colored",
      "stream": "ext://sys.stderr",
      "filters": ["stderr_filter", "only_src"]
    },
    "file_json": {
      "class": "logging.handlers.RotatingFileHandler",
      "level": "DEBUG",
      "formatter": "json",
      "filename": "src/app_logging/project_log_file.log",
      "maxBytes": 5242880,
      "backupCount": 3,
      "filters": ["only_src"]
    },
    "queue_handler": {
      "class": "logging.handlers.QueueHandler",
      "queue": "ext://queue.Queue",
      "level": "DEBUG"
    }
  },

  "loggers": {
    "src": {
      "level": "INFO",
      "handlers": ["queue_handler"],
      "propagate": false
    },
    "src.sink": {
      "level": "DEBUG",
      "handlers": ["stdout", "stderr", "file_json"],
      "propagate": false
    }
  }
}


"#
}
pub fn app_logging_constants_py() -> &'static str {
    r#"
# Define ANSI escape codes for colors
RESET = "\033[0m"
COLORS = {
    "DEBUG": "\033[36m",  # Cyan for DEBUG level
    "INFO": "\033[95m",  # light magenta
    "WARNING": "\033[33m",  # Yellow for WARNING level
    "ERROR": "\033[31m",  # Red for ERROR level
    "CRITICAL": "\033[1;31m",  # Bold Red for CRITICAL level
}

# Additional colors for log fields
FILENAME_COLOR = "\033[35m"  # Magenta for filename
FUNCNAME_COLOR = "\033[34m"  # Blue for function name
LINENO_COLOR = "\033[36m"  # Cyan for line number
TIME_COLOR = "\033[90m"  # Light gray for timestamp

if __name__ == "__main__":
    pass

"#
}
pub fn app_logging_glogger_py() -> &'static str {
    r#"
from pathlib import Path
import atexit, json, logging, logging.config
from queue import Queue

logger = logging.getLogger(__name__)
log_queue = Queue()

HERE = Path(__file__).resolve().parent
CONFIG_PATH = HERE / "config07.json"

PROJECT_LOGGER = "src"      # your top-level package
SINK_LOGGER = "src.sink"

def setup_logging():
    with CONFIG_PATH.open() as f:
        config = json.load(f)

    config["handlers"]["queue_handler"]["queue"] = log_queue
    logging.config.dictConfig(config)

    sink_handlers = logging.getLogger(SINK_LOGGER).handlers
    if not sink_handlers:
        raise RuntimeError("No sink handlers found on src.sink")

    listener = logging.handlers.QueueListener(log_queue, *sink_handlers)
    listener.start()
    atexit.register(listener.stop)

"#
}

pub fn app_logging_my_custom_json_class01_py() -> &'static str {
    r#"

import datetime as dt
import json
import logging

# from typing import override

LOG_RECORD_BUILTIN_ATTRS = {
    "args",
    "asctime",
    "created",
    "exc_info",
    "exc_text",
    "filename",
    "funcName",
    "levelname",
    "levelno",
    "lineno",
    "module",
    "msecs",
    "message",
    "msg",
    "name",
    "pathname",
    "process",
    "processName",
    "relativeCreated",
    "stack_info",
    "thread",
    "threadName",
    "taskName",
}


class MyJSONFormatter(logging.Formatter):
    def __init__(
        self,
        *,
        fmt_keys: dict[str, str] | None = None,
    ):
        super().__init__()
        self.fmt_keys = fmt_keys if fmt_keys is not None else {}

    # @override
    def format(self, record: logging.LogRecord) -> str:
        message = self._prepare_log_dict(record)
        return json.dumps(message, default=str)

    def _prepare_log_dict(self, record: logging.LogRecord):
        always_fields = {
            "message": record.getMessage(),
            "timestamp": dt.datetime.fromtimestamp(record.created, tz=dt.timezone.utc).isoformat(),
        }
        if record.exc_info is not None:
            always_fields["exc_info"] = self.formatException(record.exc_info)

        if record.stack_info is not None:
            always_fields["stack_info"] = self.formatStack(record.stack_info)

        message = {key: msg_val if (msg_val := always_fields.pop(val, None)) is not None else getattr(record, val) for key, val in self.fmt_keys.items()}
        message.update(always_fields)

        for key, val in record.__dict__.items():
            if key not in LOG_RECORD_BUILTIN_ATTRS:
                message[key] = val

        return message


class NonErrorFilter(logging.Filter):
    # @override
    def filter(self, record: logging.LogRecord) -> bool | logging.LogRecord:
        return record.levelno <= logging.INFO

"#
}
pub fn app_logging_my_filters_py() -> &'static str {
    r#"

import logging

class StdoutFilter(logging.Filter):
    """Allow only DEBUG and INFO messages for stdout."""

    def filter(self, record: logging.LogRecord) -> bool:
        return record.levelno <= logging.INFO


class StderrFilter(logging.Filter):
    """Allow only WARNING, ERROR, and CRITICAL messages for stderr."""

    def filter(self, record: logging.LogRecord) -> bool:
        return record.levelno >= logging.WARNING

"#
}

pub fn app_make_file_creator() -> &'static str {
    r#"
# === CONFIG ===
PYTHON_SRC=src


GREEN := \033[0;32m
RED := \033[0;31m
YELLOW := \033[0;33m
BLUE := \033[0;34m
NC := \033[0m # No Color
ROCKET := 🚀
CPU := 💻
GPU := ⚡️
BAR := 📊
# === RUN APP ===

.PHONY: run
run:
	@uv run python -m $(PYTHON_SRC).main

# === LINTING ===

.PHONY: lint
lint:
	@uv run ruff check $(PYTHON_SRC)

.PHONY: lint-fix
lint-fix:
	@uv run ruff check $(PYTHON_SRC) --fix

# === FORMATTING ===

.PHONY: fmt
fmt:
	@uv run black $(PYTHON_SRC)

.PHONY: fmt-check
fmt-check:
	@uv run black --check $(PYTHON_SRC)

# === TYPE CHECKING ===

.PHONY: typecheck
typecheck:
	@uv run pyright $(PYTHON_SRC)

# === TESTING ===

.PHONY: test
test:
	@uv run pytest tests/

.PHONY: coverage
coverage:
	@uv run pytest --cov=$(PYTHON_SRC) tests/

# === CLEANING ===

.PHONY: clean
clean:
	@find . -type d -name '__pycache__' -exec rm -rf {} +
	@find . -type d -name '.pytest_cache' -exec rm -rf {} +
	@rm -rf .mypy_cache .ruff_cache .coverage dist build *.egg-info .pyright

# === HELP ===



.PHONY: help
help:
	@echo " "
	@echo "$                                      "
	@echo "$                                      "
	@echo "$                                      "
	@echo " "
	@echo "Available make targets:"
	@echo "  run          Run the main application"
	@echo "  lint         Run Ruff linter"
	@echo "  lint-fix     Run Ruff with auto-fix"
	@echo "  fmt          Format code with Black"
	@echo "  fmt-check    Check formatting with Black"
	@echo "  typecheck    Static type check with Pyright"
	@echo "  test         Run Pytest"
	@echo "  coverage     Run tests with coverage report"
	@echo "  clean        Remove build/test/cache artifacts"


    "#
}
